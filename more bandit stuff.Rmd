---
title: "R Notebook"
output: html_notebook
---

```{r}
library(knitr)
library(RPostgreSQL)
library(dplyr)
library(ggplot2)


myRedshift <- src_postgres('cust_analytics_prd',
                           host = 'a0036-ei-analytics.c9gybgr1jgvx.us-west-2.redshift.amazonaws.com',
                           port = 5439,
                           user = "datalab", 
                           password = "DataLab1")

dat <- tbl(myRedshift, sql(
  paste0(
    "select
    min(session_date) session_date,
    arm,
    case
      when sum(rec_engagement) > 0 then 1
      else 0
    end rec_engagement,
    case
      when sum(did_purchase) > 0 then 1
      else 0
    end did_purchase
    from (
      select 
        c.cookie_id,
        c.session_id,
        c.session_date,
        c.arm,
        case
          when r.session_id is null then 0
          else 1
        end rec_engagement,
        case
          when p.session_id is null then 0
          else 1
        end did_purchase
      from analytics_user_vws.pdp_eda_cohort c
        left join analytics_user_vws.pdp_eda_rec_clks r on r.session_id = c.session_id
        left join analytics_user_vws.pdp_eda_item_purchases p on p.session_id = c.session_id
      where test = 2
    )
    group by cookie_id, arm
    order by session_date asc"
  )))

dat <- collect(dat, n=Inf)

```


```{r}

dat %>%
  group_by(arm, rec_engagement) %>%
  summarise(ct = n(), purs = sum(did_purchase)) %>%
  mutate(prop = purs/ct)
  
```
```{r}
dat %>%
  group_by(arm) %>%
  summarise(ct = n(), purs = sum(did_purchase)) %>%
  mutate(prop = purs/ct)
```



```{r}

library(MASS)

get_theta_hat_alpha <- function(b_rec, A_rec, B_rec, beta_hat){
  return(ginv(A_rec) %*% (b_rec - B_rec %*% beta_hat))
}

get_s_t_rec <- function(z_t_rec, A_0, B_rec, A_rec, x_t_rec){
  A_0_inv <- ginv(A_0)
  A_rec_inv <- ginv(A_rec)
  s_t_rec <- (t(z_t_rec) %*% A_0_inv %*% z_t_rec) - 
    2*(t(z_t_rec) %*% A_0_inv %*% t(B_rec) %*% A_rec_inv %*% x_t_rec) +
    (t(x_t_rec) %*% A_rec_inv %*% x_t_rec) +
    (t(x_t_rec) %*% A_rec_inv %*% B_rec %*% A_0_inv %*% t(B_rec) %*% A_rec_inv %*% x_t_rec)
  return(s_t_rec)
}

get_p_t_rec <- function(z_t_rec, beta_hat, x_t_rec, theta_hat_alpha, alpha, s_t_rec){
  p_t_rec <- (t(z_t_rec) %*% beta_hat) +
    (t(x_t_rec) %*% theta_hat_alpha) +
    alpha * sqrt(s_t_rec)
  return(p_t_rec)
}

######################################################
### Update shtuff
######################################################

update_A_0 <- function(A_0, B_rec, A_rec){
  A_rec_inv <- ginv(A_rec)
  New_A_0 <- A_0 + (t(B_rec) %*% A_rec_inv %*% B_rec)
  return(New_A_0)
}

update_b_0 <- function(b_0, B_rec, A_rec, b_rec){
  A_rec_inv <- ginv(A_rec)
  new_b_0 <- b_0 + (t(B_rec) %*% A_rec_inv %*% b_rec)
  return(new_b_0)
}

update_A_rec <- function(A_rec, x_t_rec){
  return(A_rec + x_t_rec %*% t(x_t_rec))
}

update_B_rec <- function(B_rec, x_t_rec, z_t_rec){
  return(B_rec + x_t_rec %*% t(z_t_rec))
}

update_b_rec <- function(b_rec, r_t, x_t_rec){
  return(b_rec + r_t * x_t_rec)
}

update_A_0_again <- function(A_0, z_t_rec, B_rec, A_rec){
  A_rec_inv <- ginv(A_rec)
  A_0_new <- A_0 + (z_t_rec %*% t(z_t_rec)) - (t(B_rec) %*% A_rec_inv %*% B_rec)
  return(A_0_new)
}

update_b_0_again <- function(b_0, r_t, z_t_rec, B_rec, A_rec, b_rec){
  A_rec_inv <- ginv(A_rec)
  new_b_0 <- b_0 +
    (r_t * z_t_rec) -
    (t(B_rec) %*% A_rec_inv %*% b_rec)
  return(new_b_0)
}

# Trials, the number of trials
trials <- 2000
# arms TODO: fix this so arms can vary
arms <- 3
# alpha, arbitarily set to 3
alpha <- 3
# dimensions of the single arm features, d
d <- 1
# dimensions of the shared features, k
k <- 1
# A0, a k-dimensional identity matrix
A_0 <- diag(k)
# B0, a k-length zero vector
b_0 <- matrix(0, k, 1)
# A, list of matrices for each arm
A <- list()
# B, list of matrices for each arm
B <- list()
# b, list of vectors for each arm
b <- list()
#theta, list to hold theta hat
theta <- list()
#s_t_a matrix
s_t_a <- matrix(0, trials, arms)
p_t_a <- matrix(0, trials, arms)
#arm choice vector
arm_choice <- c()
#reward vector
reward <- c()

arm_data <- data_frame(
  name = unique(dat$arm),
  num = c(3, 1, 2)
)



for (t in 1:trials){
  
  beta_hat <- ginv(A_0) %*% b_0
  
  for (a in 1:arms){
    
    if(t == 1){
      A[[a]] <- diag(d)
      B[[a]] <- matrix(0, d, k)
      b[[a]] <- matrix(0, d, 1)
    }
    
    theta[[a]] <- get_theta_hat_alpha(b[[a]], A[[a]], B[[a]], beta_hat)
    
    z_t_rec <- matrix(as.numeric(a), 1, 1)
    x_t_rec <- matrix(as.numeric(a), 1, 1)
    
    s_t_a[[t, a]] <- get_s_t_rec(z_t_rec, A_0, B[[a]], A[[a]], x_t_rec)
    p_t_a[[t, a]] <- get_p_t_rec(z_t_rec, beta_hat, x_t_rec, theta[[a]], alpha, s_t_a[[t, a]])
  
  }

  arm_choice[t] <- which(p_t_a[t,] == max(p_t_a[t,]))
  #changing this reward policy will cause the alg to solve differently (meaning this works!!!!)
  reward[t] <- if(arm_data$name[which(arm_data$num == arm_choice[t])] == dat$arm[t]){
    reward[t] <- dat$did_purchase[t]
  }else{
    next
  }
  
  z_t_rec <- matrix(as.numeric(c(dat$rec_engagement[t], a)), 1, 1)
  x_t_rec <- matrix(as.numeric(c(dat$rec_engagement[t], a)), 1, 1)
  
  A_0 <- update_A_0(A_0, B[[arm_choice[t]]], A[[arm_choice[t]]])
  b_0 <- update_b_0(b_0, B[[arm_choice[t]]], A[[arm_choice[t]]], b[[arm_choice[t]]])
  A[[arm_choice[t]]] <- update_A_rec(A[[arm_choice[t]]], x_t_rec)
  B[[arm_choice[t]]] <- update_B_rec(B[[arm_choice[t]]], x_t_rec, z_t_rec)
  b[[arm_choice[t]]] <- update_b_rec(b[[arm_choice[t]]], reward[t], x_t_rec)
  A_0 <- update_A_0_again(A_0, z_t_rec, B[[arm_choice[t]]], A[[arm_choice[t]]])
  b_0 <- update_b_0_again(b_0, reward[t], z_t_rec, B[[arm_choice[t]]], A[[arm_choice[t]]], b[[arm_choice[t]]])

}


new_dat <- data_frame(reward, arm_choice)

old_dat <- dat[1:trials,]

new_dat <- cbind(new_dat, old_dat)

new_dat <- new_dat %>%
  filter(!is.na(reward))

new_dat %>%
  group_by(arm_choice) %>%
  summarise(ct = n(), r = sum(reward, na.rm = T)) %>%
  mutate(prop = r/ct)

```




